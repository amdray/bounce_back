### Документация файла: MANIFEST.MF

- Общее описание:
Данный файл является манифестом JAR-архива для приложения Java ME (J2ME). Он содержит метаданные приложения, необходимые для его идентификации, установки и запуска мобильным устройством (Application Management Software). Приложение называется «Bounce Back» и разработано компанией Nokia.
- Архитектурная роль:
Конфигурационный слой / Дескриптор развертывания. Этот файл определяет точку входа в приложение и требуемую среду выполнения (конфигурацию и профиль). Он связывает скомпилированный код с ресурсами и системными требованиями устройства.
- Внешние зависимости:
В файле указаны ссылки на следующие компоненты, которые должны присутствовать в JAR-архиве или среде исполнения:CrystalMidlet: Основной класс приложения (Main Class), расширяющий javax.microedition.midlet.MIDlet./res/i: Путь к файлу иконки приложения в ресурсах.CLDC-1.0: Минимальная конфигурация ограниченного устройства (Connected Limited Device Configuration).MIDP-1.0: Профиль мобильной информационной системы (Mobile Information Device Profile).

- Константы (Параметры манифеста):

Ниже приведены жестко заданные значения параметров приложения:

| Параметр | Значение | Описание |
| --- | --- | --- |
| MIDlet-Name | Bounce Back | Название приложения |
| MIDlet-Vendor | Nokia | Поставщик |
| MIDlet-Version | 1.13 | Версия приложения |
| MIDlet-1 |Bounce Back, /res/i, CrystalMidlet | Определение первого (и основного) мидлета в пакете |
| MicroEdition-Configuration | CLDC-1.0 | Требуемая версия конфигурации Java |
| MicroEdition-Profile | MIDP-1.0 | Требуемая версия профиля Java |
| Created-By | 1.4.1_02 (Sun Microsystems Inc.) | Разработчик |

---

### Документация файла: CrystalMidlet.java

#### Общее описание:
Данный класс является центральным узлом приложения (MIDlet). Он управляет жизненным циклом программы, переключением игровых состояний (меню, игровой процесс, рекорды, справка), обработкой пользовательских команд и сохранением данных. Класс активно использует специфичные для устройств Nokia API для управления подсветкой, вибрацией и звуком.
#### Архитектурная роль:
Main Controller (Главный контроллер). Класс реализует паттерн «Состояние» (через переменную k), координируя взаимодействие между графическим интерфейсом (класс i), игровым движком (класс h) и системой хранения данных (RMS).
#### Внешние зависимости:
Класс взаимодействует со следующими компонентами и библиотеками:
Внутренние классы приложения:
- h: Игровой холст/логика (Game Canvas).
- i: Пользовательский интерфейс (Menu/UI system).
- c: Загрузчик ресурсов (Sound/Resource loader).
- d: Вспомогательный класс (вероятно, для работы с графикой или уровнями).

Стандартные библиотеки J2ME:
- javax.microedition.midlet.MIDlet: Базовый класс приложения.
- javax.microedition.lcdui.*: Управление экраном и командами.
- javax.microedition.rms.RecordStore: Постоянное хранение данных.

Nokia UI/Sound API:
- com.nokia.mid.sound.Sound: Обработка звуковых эффектов.com.
- nokia.mid.ui.DeviceControl: Управление аппаратными функциями (подсветка, вибрация).

Файлы ресурсов:

- /res/s: Файл с данными звуков.

#### Список функций (Методы):

| Название | Описание |
| --- | --- |
| startApp() | Инициализация приложения: включение подсветки, загрузка данных из RMS и запуск главного меню. |
| pauseApp() | Приостановка игры и оповещение активных компонентов (h и i) о паузе. |
| destroyApp(bool) | Завершение работы: сохранение текущего прогресса в RMS и освобождение ресурсов. |
| a(int) | Обновление таблицы рекордов (вставка нового значения со сдвигом существующих). |
| b(boolean) | Инициализация и отображение главного меню. |
| a() | Формирование и отображение списка доступных уровней (Level Select). |
| i() | Отображение меню настроек (звук, вибрация). |
| j() | Отображение таблицы пяти лучших рекордов. |
| e() | Отображение справочного меню (Help). |
| g() | Отображение экрана с описанием управления. |
| c() | Обработка завершения уровня: расчет бонусов за время и отображение итогов. |
| a(boolean) | Отображение финального поздравительного экрана при прохождении всех уровней. |
| f() | Логика завершения игры (Game Over): проверка рекордов и вывод статистики. |
| a(bool, bool) | Запуск нового игрового процесса или конкретного уровня. |
| d() | Возобновление (Resume) текущей игры. |
| h() | Сброс и запуск игры с демонстрационным режимом или специальным состоянием. |
| commandAction(...) | Центральный обработчик всех нажатий кнопок меню (Select, Back, Exit). |
| b() | Загрузка данных (уровни, настройки, рекорды, состояние сейва) из RMS CrystalRMS. |
| d(int) | Сохранение данных в RMS (1: макс. уровень, 2: настройки/рекорды, 3: состояние игры). |
| a(String, int) | Утилита для подстановки числового значения в строку (аналог printf для {0}). |
| a(int, int) | Загрузка звуковых ресурсов из файла /res/s в массив объектов Sound. |
| b(int) | Воспроизведение звукового эффекта по индексу с учетом настроек пользователя. |

- Константы и захардкоженные данные:

| Имя / Значение | Тип | Описание |
| --- | --- | --- |
| "CrystalRMS" | String | Имя хранилища данных в Record Management System. |
| r | String[] | Пункты главного меню (Continue, New Game, Options и т.д.). |
| z, E | String[] | Тексты для разделов справки и управления. |
| l, w, d, b | String[] | Шаблоны строк для результатов уровня и игровых сообщений. |
| "/res/s" | String | Путь к ресурсу со звуковыми данными. |
| 21 | int | Максимальное количество доступных уровней. |
| 1200 | int | Базовое значение для расчета временного бонуса на уровне. |

---

### Документация файла: i.java

#### Общее описание:
Данный класс является универсальным графическим движком для отображения пользовательского интерфейса (меню, текстовых экранов, списков рекордов и справок). Он поддерживает анимацию переходов (появление/исчезновение), обработку ввода с клавиатуры и джойстика, а также автоматический перенос текста. Класс оптимизирован под устройства Nokia (использует FullCanvas и DirectGraphics).
#### Архитектурная роль:
UI Rendering Engine (Графический движок интерфейса). В архитектуре приложения этот класс отвечает за визуализацию всех экранов, кроме самого игрового процесса. Он отделяет логику управления состояниями (в CrystalMidlet) от процесса отрисовки и анимации элементов интерфейса.
#### Внешние зависимости:
Класс тесно интегрирован с системными и кастомными компонентами:

Системные (Nokia & MIDP): 
- com.nokia.mid.ui.FullCanvas: Базовый класс для полноэкранного режима.
- com.nokia.mid.ui.DirectUtils, DirectGraphics: Для расширенных операций рисования (например, зеркальное отражение изображений).

Внутренние классы:
- CrystalMidlet: Главный класс для вызова бизнес-логики и проигрывания звуков.
- f: Вспомогательный класс-таймер (предположительно TimerTask или поток для анимации).
- c: Загрузчик ресурсов (используется для чтения графики).

Файлы ресурсов:

- /res/im: Файл-пакет с графическими ресурсами (логотипы, иконки, элементы фона).

---

### Список функций (Методы):

| Название | Описание |
| --- | --- |
| i(int, int, int) | Конструктор для создания базового холста с параметрами задержки анимации. |
| a(int) | Логика обработки игровых действий (Game Actions): навигация вверх/вниз, выбор, возврат. |
| paint(Graphics) | Главный метод отрисовки. Управляет слоями: фон, логотип, пункты меню, анимации перехода. |
| run() | Потоковый метод для управления кадрами анимации (уменьшение счетчиков W и v). |
| a(String[]) | Инициализация стандартного списка строк для меню. |
| a(Graphics, String, ...) | Сложная функция рендеринга текста с автоматическим переносом по словам и поддержкой символа \n. |
| a(String[], byte, String, String, String, byte) | Основной метод настройки экрана: задает заголовок, пункты меню, типы команд и стиль оформления. |
| a(String[], String[], byte, ...) | Настройка экрана для отображения больших блоков текста (например, Help/Controls). |
| keyPressed(int) | Обработчик нажатий клавиш. Включает поддержку чит-кодов (последовательность нажатий в переменную s). |
| b(Graphics) | Отрисовка статических элементов интерфейса: фона, декоративных боковых панелей и подписей к софт-клавишам. |
| d(Graphics, int) | Отрисовка анимированного появления элементов или заставки (Splash screen). |
| c(boolean) | Загрузка графических ресурсов из /res/im и подготовка изображений (включая DirectGraphics операции). |
| a(String) | Утилита для сокращения длинных строк (добавление «...» в конце, если текст не влечет в экран). |

---

### Константы и захардкоженные данные:

| Значение | Тип | Описание |
| --- | --- | --- |
| "/res/im" | String | Путь к файлу с графическими данными. |
| 176, 208 | int | Размеры экрана (ширина и высота), соответствующие разрешению Nokia S60. |
| 30702 | int (Color) | Цвет фона (зеленоватый оттенок). |
| 16777215 | int (Color) | Белый цвет (используется для текста). |
| 187 | int (Color) | Цвет заливки рамки выделенного пункта меню. |
| 18 | int | Высота одной строки в меню (межстрочный интервал). |
| 9 | int | Максимальное количество строк меню, одновременно отображаемых на экране. |
| 64 | int | Константа стиля шрифта (Font.FACE_SYSTEM). |
| "-6", "-7" | int | Коды левой и правой софт-клавиш для устройств Nokia. |


---

### Документация файла: f.java

#### Общее описание:
Данный класс является служебной оберткой над стандартными системными классами java.util.Timer и java.util.TimerTask. Он предназначен для упрощения организации периодического выполнения задач. Класс принимает объект, реализующий интерфейс Runnable, и выполняет его метод run() через равные промежутки времени.
#### Архитектурная роль:
Utility / Timing Layer (Уровень синхронизации и таймеров).  В контексте данного приложения класс f выступает в роли «сердцебиения» для графического интерфейса или игровой логики. Он обеспечивает циклическое обновление состояний (например, анимаций в классе i), делегируя фактическую работу внешнему объекту.
#### Внешние зависимости:

Класс использует стандартные средства Java ME для работы с потоками и временем:

- java.util.Timer: Используется для планирования задач в фоновом потоке.
- java.util.TimerTask: Базовый класс, позволяющий объекту быть запланированным в Timer.
- java.lang.Runnable: Интерфейс задачи, которую необходимо выполнять.

#### Список функций (Методы):

| Название | Описание |
| --- | --- |
| f(Runnable, int) | Конструктор класса. Инициализирует новый системный таймер и планирует выполнение задачи paramRunnable с интервалом paramInt миллисекунд. Выполнение начинается незамедлительно (задержка 0 мс). |
| run() | Стандартный метод TimerTask. При каждом срабатывании таймера он вызывает метод run() у делегированного объекта b. |
| a() | Метод остановки. Отменяет выполнение текущей задачи и останавливает поток таймера, после чего обнуляет ссылку на объект таймера для освобождения памяти. |

- Константы и захардкоженные данные:

| Значение | Тип | Описание |
| --- | --- | --- |
| 0L | long | Параметр delay в методе schedule. Указывает на то, что первое выполнение задачи должно произойти сразу после вызова конструктора. |

---

### Документация файла: h.java

#### Общее описание:
Данный класс является основным игровым движком (Game Engine). Он отвечает за загрузку уровней, симуляцию игровой физики, обработку столкновений, управление анимацией объектов и рендеринг игрового мира. Класс объединяет слои бэкграунда и фронтграунда, управляет персонажем и движущимися препятствиями.
#### Архитектурная роль:
Game Controller & Renderer (Игровой контроллер и рендерер). Это центральный элемент игрового процесса, который связывает визуальное представление (Canvas) с логикой игрового цикла (Runnable). Он управляет состоянием мира, считывает данные уровней из бинарных ресурсов и координирует работу вспомогательных классов (a — игрок, g — карты слоев).

#### Внешние зависимости:
Класс активно взаимодействует с внутренними компонентами и ресурсами:

Внутренние классы:

- CrystalMidlet (ссылка H): Управление состояниями приложения и звуком.
- a (объект e): Класс игрового персонажа (Player).
- g (объекты Z, A): Класс управления тайловыми картами (Level Maps).
- c: Загрузчик бинарных данных.
- d, e: Вспомогательные классы для отображения UI-элементов и сценариев.
- f: Таймер для управления игровым циклом.

Файловые ресурсы:

- /res/lf: Бинарные данные конфигурации уровней.
- /res/tf: Данные тайлов (Tile Front).
- /res/bg: Данные фонов (Background).
- /res/ic: Иконки и игровые спрайты.
- /res/if0, /res/if[n]: Изображения слоев переднего плана.
- /res/ib0, /res/ib[n]: Изображения фоновых слоев.

---

### Список функций (Методы):

| Название | Описание |
| --- | --- |
| h(CrystalMidlet) | Конструктор: инициализирует среду выполнения, устанавливает шрифты и базовые параметры игрока. |
| a(int) | Устанавливает флаг загрузки конкретного уровня. |
| b(int) | Загрузка уровня: читает данные из /res/lf, инициализирует объекты g (карты), расставляет объекты, устанавливает начальную позицию игрока и загружает графику тайлов. |
| i() | Загрузка статических графических ресурсов (спрайты игрока, иконки, элементы интерфейса) из /res/ic. |
| f() | Устанавливает флаг завершения работы или перехода. |
| b() | Восстановление состояния: загружает сохраненную игру из RMS CrystalRMS, включая координаты игрока, текущие бонусы, состояние тайлов на карте и траектории врагов. |
| a(DataOutputStream) | Сохранение состояния: записывает все текущие параметры игры (уровень, счет, позиция, модифицированные тайлы) в поток данных для RMS. |
| paint(Graphics) | Главный метод отрисовки: поочередно рисует фон, карту уровня, игровые объекты, персонажа и оверлеи (сообщения о загрузке, уровень). |
| run() | Игровой цикл: обрабатывает логику перемещения, столкновения, обновляет позиции движущихся платформ/врагов, обновляет анимации тайлов и инициирует перерисовку. |
| keyPressed / keyReleased | Обработка ввода: поддерживает управление через джойстик и цифровую клавиатуру (2, 4, 5, 6), а также обрабатывает софт-клавиши и чит-коды. |
| d() | Логика поведения движущихся объектов (врагов/платформ): расчет траекторий, скоростей и проверка столкновений с игроком. |
| g() | Анимация «разрушаемых» или временных тайлов (например, исчезающие блоки). |
| a(int, int, int, int, ...) | Утилита для проверки пересечения прямоугольных областей (Collision Detection). |

---

### Константы и захардкоженные данные:

| Значение | Тип | Описание |
| --- | --- | --- |
| "CrystalRMS" | String | Имя хранилища данных Record Store. |
| "/res/lf", "/res/tf", ... | String | Пути к папкам ресурсов игры. |
| 16 | int | Размер одного тайла в пикселях. |
| 176, 179, 208 | int | Размеры игрового экрана и буферов отрисовки. |
| 12, 14, 24, 32 | int | Жестко заданные размеры спрайтов и хитбоксов врагов. |
| 8192, 270, 180 | int | Флаги трансформации изображений для DirectGraphics (отражение, поворот). |
| 4, 6, 2, 5 | int | Коды клавиш управления (движение и прыжок). |
| 93, 94, 97, 101 | int | ID специальных тайлов (интерактивные объекты, препятствия). |

---

### Документация файла: b.java

- Общее описание:
Данный класс представляет собой простую структуру данных (Data Container), организованную по принципу односвязного списка. Он предназначен для хранения трех разнотипных значений и ссылки на следующий элемент этого же типа. Учитывая типы данных (short, int, byte), класс может использоваться для хранения координат, идентификаторов объектов или параметров состояния в компактном виде.
- Архитектурная роль:
Data Model / Node (Узел данных). В архитектуре приложения этот класс выполняет роль элементарного звена в цепочке данных. Он используется для динамического создания списков без использования тяжеловесных коллекций Java (таких как Vector), что критично для устройств с ограниченной памятью (CLDC 1.0/MIDP 1.0).
- Внешние зависимости:
Класс является полностью автономным и не имеет внешних зависимостей от системных библиотек или других классов приложения.

---

### Список функций (Методы):

| Название | Описание |
| --- | --- |
| b(short, int, byte) | Конструктор. Инициализирует поля данных d, b и c переданными значениями и устанавливает указатель на следующий элемент a в состояние null. |

---

### Поля данных (Переменные):

Поскольку в классе отсутствуют методы обработки, важную роль играют его публичные поля:

| Имя поля | Тип | Описание |
| --- | --- | --- |
| d | short | Короткое целое число (вероятно, координата или ID). |
| b | int | Целое число (вероятно, значение счета, время или хеш). |
| c | byte | Байт (вероятно, тип объекта, флаг или состояние). |
| a | b | Указатель на следующий объект типа b. Ключевой элемент для создания связанного списка. |

---

### Константы:

Захардкоженные константы в данном файле отсутствуют. Значения устанавливаются динамически при создании объекта через конструктор.

---

### Документация файла: g.java

#### Общее описание:
Данный класс представляет собой тайловый движок (Tile Engine), оптимизированный для работы на мобильных устройствах. Он отвечает за низкоуровневое управление игровым миром: загрузку карт из бинарных массивов, управление наборами плиток (tilesets), обработку анимаций внутри тайлов и, самое важное, за расчет попиксельных столкновений (Collision Detection). Класс поддерживает трансформации тайлов (поворот, зеркальное отражение) через Nokia DirectGraphics и реализует систему «грязных прямоугольников» или буферизацию для эффективного скроллинга.
#### Архитектурная роль:
Environment & Physics Layer (Слой окружения и физики). Это фундаментальный компонент визуализации и физического взаимодействия. Он предоставляет классу h (движку игры) интерфейс для отрисовки фона и проверки, может ли игровой персонаж пройти через конкретную точку пространства.
#### Внешние зависимости:

Внутренние классы:
- c: Загрузчик ресурсов (используется для последовательного чтения графических фрагментов).

Системные библиотеки:

- com.nokia.mid.ui.DirectGraphics / DirectUtils: Для продвинутых графических манипуляций.
- javax.microedition.lcdui.*: Стандартные средства рисования.

---

### Список функций (Методы):

| Название | Описание |
| --- | --- |
| g(...) | Конструктор. Масштабная инициализация: парсинг заголовков карты, загрузка изображений тайлов через класс c, инициализация масок столкновений и массивов анимаций. |
| c(int, int) | Установка координат камеры (Viewport). Рассчитывает смещение относительно размеров всей карты. |
| d() | Обновление состояния. Обновляет таймеры анимации тайлов (смена кадров в массиве m) и инициирует логику перерисовки буфера. |
| a(int, int, int, int, bool[][], bool) | Collision Detection. Проверяет пересечение заданного прямоугольника (объекта) с твердыми тайлами карты. Использует маски столкновений для точности. |
| a(Graphics) | Отрисовка. Выводит текущую видимую область карты на экран. Поддерживает циклическую прокрутку (бесконечный фон). |
| c() | Инициализация графического буфера (Image F) для оптимизации рендеринга. Рассчитывает размеры видимой области. |
| b() | Внутренняя логика определения «грязных» областей при скроллинге для частичной перерисовки буфера. |
| a(int, int) | Вспомогательные методы для нормализации координат (обработка краев карты и зацикливания). |

---

### Константы и захардкоженные данные:

| Значение | Тип | Описание |
| --- | --- | --- |
| p (массив) | int[] | Набор флагов трансформации Nokia API: 0, 90, 180, 270 градусов, а также зеркальные отражения (16384 и др.). |
| 127 (z) | int | Битовая маска для извлечения ID тайла из байта данных карты. |
| 128 (q) | int | Битовый флаг, определяющий прозрачность или особые свойства тайла. |
| 2130706559 | int | Цвет заливки по умолчанию (в формате ARGB) для пустых областей. |
| 16 | int | Базовый размер тайла в пикселях (используется для создания заглушки N). |
| 5 | int | Фиксированный размер вспомогательных массивов Y и P для хранения координат коллизий. |

---

### Архитектурные особенности:

1. Система анимаций: В классе реализована поддержка многокадровых тайлов. Массив m хранит последовательности ID тайлов, а O и aa — задержки между кадрами.
2. Оптимизация памяти: Если установлен флаг ab, оригинальные изображения тайлов V удаляются после создания трансформированных копий в E, чтобы освободить Heap.
3. Гибкая физика: Переменная l определяет тип тайла: 0 — проходимый, 1 — со сложной маской столкновений, 2 — полностью твердый блок, 3 — наследуемая физика.

---

### Документация файла: a.java

#### Общее описание:
Данный класс является контроллером игрока (Player Controller). Он инкапсулирует в себе всю логику поведения главного героя: физику перемещения, расчет прыжков, обработку столкновений с окружением и врагами, управление состояниями (бонусы, смерть, смена формы) и анимацию. Класс считывает маски коллизий из ресурсов, чтобы обеспечить точное взаимодействие спрайта игрока с тайлами карты.
#### Архитектурная роль:
Entity Logic (Логика сущности). В архитектуре игры это центральный объект взаимодействия. Он выступает связующим звеном между вводом пользователя (через h.java) и физическим миром (g.java).
#### Внешние зависимости:

Класс активно использует следующие компоненты:

Внутренние классы:

- CrystalMidlet (объект o): Для начисления очков, изменения количества жизней и воспроизведения звуков.
- h (объект E): Основной игровой движок для доступа к списку врагов и глобальным переменным уровня.
- g (объект v): Тайловый движок для проверки проходимости координат.
- c: Загрузчик бинарных ресурсов.

Файловые ресурсы:

- /res/b: Файл, содержащий бинарные маски коллизий и массив спрайтов игрока.

---

### Список функций (Методы):

| Название | Описание |
| --- | --- |
| a(...) | Конструктор. Загружает маски коллизий и 25 графических спрайтов игрока из ресурса /res/b. |
| a(int, int, int) | Инициализация или сброс состояния игрока в начальных координатах. |
| e() | Логика возрождения (Respawn): уменьшение счетчика жизней и возвращение к последнему чекпоинту. |
| k() | Перевод игрока в состояние смерти (активация флага e). |
| a(int, int) | Обновление состояния тайла на карте (используется для активации чекпоинтов). |
| c(int) / b(int) | Управление битовой маской ввода (установка/снятие флагов движения и прыжка). |
| a(int, int, bool) | Collision Detection. Проверка столкновения игрока с тайлами мира или движущимися платформами. |
| a(int) | Смена текущего спрайта игрока с автоматической корректировкой позиции, чтобы персонаж не «застрял» в текстурах при изменении размера. |
| b(int, int) | Обработка взаимодействия с предметами: сбор кристаллов (30, 34), дополнительных жизней (12) и прохождение через кольца (93-102). |
| c(int, int) | Обработка специальных зон: прыжковые панели, зоны ускорения, инверсия гравитации. |
| l(), b(), c() | Методы-триггеры для начала выполнения прыжка или спецприемов. |
| h(), f() | Расчет динамических параметров физики (высота прыжка, гравитация) в зависимости от текущих бонусов. |
| d() | Update Loop. Главный цикл обновления: применение гравитации, обработка ввода, циклическая проверка столкновений по осям X и Y, обновление таймеров бонусов. |
| a(Graphics) | Отрисовка спрайта игрока на экране с учетом текущей анимации или эффекта смерти. |

---

### Константы и захардкоженные данные:

| Значение | Тип | Описание |
| --- | --- | --- |
| "/res/b" | String | Путь к ресурсу с физическими масками и графикой игрока. |
| 25 | int | Общее количество кадров анимации игрока. |
| 16 | int | Размер одного тайла (используется для конвертации координат в индексы сетки). |
| 200, 500, 1000, 2500 | int | Наградные очки за сбор различных типов бонусов. |
| 450, 550 | int | Длительность действия состояний (таймеры бонусов или неуязвимости). |
| 34 | int | ID тайла «Чекпоинт». |
| 12 | int | ID тайла «Дополнительная жизнь». |
| 30 | int | ID тайла «Большой кристалл». |
| 93 - 104 | int | Диапазон ID тайлов интерактивных колец. |
| 15, 26, 39 | int | ID тайлов-модификаторов состояния игрока (прыжок, инверсия и т.д.). |

---

**Архитектурная заметка:**
Класс реализует сложную систему «выталкивания» спрайта: в методе `a(int)` при смене спрайта (например, если персонаж вырос в размере), код ищет ближайшую свободную позицию в радиусе, чтобы избежать наложения коллизий спрайта на твердые тайлы.

---

### Документация файла: c.java

- Общее описание:
Данный класс является специализированным загрузчиком ресурсов (Resource Loader), предназначенным для чтения упакованных бинарных данных из JAR-архива приложения. Он реализует механизм работы с кастомным форматом пакетов, где в начале файла содержится заголовок с количеством записей и их длинами, что позволяет извлекать конкретные сегменты данных по индексу. Класс поддерживает как последовательное чтение, так и произвольный доступ (random access) к записям путем перезапуска входного потока.
- Архитектурная роль:
Resource Management / Data Access Layer (Слой управления ресурсами). Этот класс служит низкоуровневой прослойкой между файловой системой JAR-архива и игровыми объектами. Он используется другими классами (например, a.java, g.java, h.java) для загрузки спрайтов, карт уровней и звуковых данных, избавляя их от необходимости знать структуру хранения байтов.
- Внешние зависимости:
Класс использует стандартные средства ввода-вывода Java ME:java.io.InputStream: Основной поток для чтения данных из ресурсов.java.io.IOException: Обработка ошибок при работе с потоком.getClass().getResourceAsStream(String): Метод для получения доступа к файлам внутри JAR.

---

### Список функций (Методы):

| Название | Описание |
| --- | --- |
| c(String) | Конструктор. Принимает путь к файлу ресурса. Читает заголовок: первые 2 байта определяют количество записей (f), последующие байты заполняют массивы смещений (a) и длин (i) для каждой записи. |
| a() | Последовательное чтение. Извлекает текущую запись (индекс d) в виде массива байтов. После выполнения увеличивает индекс для следующего вызова. |
| c(int) | Чтение по индексу. Вызывает метод позиционирования a(int) и затем считывает данные через a(). |
| a(int) | Позиционирование. Перемещает указатель чтения к началу записи с указанным индексом. Если индекс больше текущего, выполняется пропуск байтов (skip). Если меньше — поток закрывается и открывается заново для чтения с начала файла. |
| b(int) | Гарантированный пропуск. Внутренняя утилита, которая заставляет поток пропустить ровно paramInt байтов, повторяя операцию skip, если системный метод вернул меньше байтов, чем запрашивалось. |

---

### Константы и захардкоженные данные:

| Значение | Тип | Описание |
| --- | --- | --- |
| << 8 | int | Используется для сборки 16-битных целых чисел (Short) из двух последовательных байтов заголовка. |
| (f + 1) * 2 | int | Расчет начального смещения первой записи данных после завершения заголовка. |

---

### Технические особенности реализации:

Класс оптимизирован для работы в условиях CLDC 1.0, где отсутствуют средства произвольного доступа к ресурсам (как `RandomAccessFile`). Механизм перезапуска потока (`this.e.close()` и `getResourceAsStream`) в методе `a(int)` является стандартным способом реализации "перемотки" данных назад в Java ME.


---

### Документация файла: d.java

- Общее описание:
Данный класс реализует систему воспроизведения записи (Replay System). Он предназначен для считывания последовательности игровых событий (нажатий клавиш или действий) из бинарного ресурсного файла и их последовательной имитации. Класс загружает данные в связный список и пошагово обновляет массив состояния ввода, что позволяет воссоздать игровой процесс (например, для режима демонстрации или обучения).
- Архитектурная роль:
Input Replay / Simulation Layer (Уровень симуляции ввода). Этот компонент заменяет реального игрока, подавая команды напрямую в массив управления, который обычно используется движком h.java. Он связывает статические данные из ресурсов с динамическим состоянием игрового цикла.
- Внешние зависимости:
Класс взаимодействует со следующими компонентами:Класс b: Используется как узел (node) связного списка для хранения параметров каждого записанного события (время/тик, код команды, значение).Ресурс res/r: Бинарный файл, содержащий поток данных для записи (replay stream).Стандартные библиотеки: java.io.DataInputStream для парсинга структурированных данных.

---

### Список функций (Методы):

| Название | Описание |
| --- | --- |
| a() | Загрузка данных. Открывает поток к файлу res/r, считывает последовательности short (время/тик), int (код действия) и byte (значение) до конца файла. Создает объекты b и формирует из них связный список. |
| a(b paramb) | Добавление в список. Вспомогательный метод для построения связного списка. Добавляет новый узел paramb в конец цепочки. |
| a(byte[] paramArrayOfbyte) | Воспроизведение. Проверяет, есть ли в списке события, запланированные на текущий шаг b. Если есть, обновляет соответствующие ячейки массива состояний ввода (индексы 0–5) значениями из записи и переходит к следующему событию. В конце инкрементирует внутренний счетчик тиков b. |

---

### Константы и захардкоженные данные:

Ниже приведены идентификаторы действий, которые распознаются при чтении записи и транслируются в массив состояний:

| Значение | Тип | Описание |
| --- | --- | --- |
| "res/r" | String | Путь к бинарному файлу с данными записи игрового процесса. |
| 8 | int | Код события: записывается в paramArrayOfbyte[0] (вероятно, "Вверх" или "Прыжок"). |
| 4 | int | Код события: записывается в paramArrayOfbyte[1] (вероятно, "Вниз"). |
| 1 | int | Код события: записывается в paramArrayOfbyte[2] (вероятно, "Влево"). |
| 2 | int | Код события: записывается в paramArrayOfbyte[3] (вероятно, "Вправо"). |
| 20 | int | Специальный триггер: устанавливает paramArrayOfbyte[4] в значение 1. |
| 21 | int | Код события: записывается в paramArrayOfbyte[5]. |

---

### Документация файла: e.java

- Общее описание:
Данный класс представляет собой упрощенную структуру данных (Data Container), предназначенную для хранения состояния или группы связанных объектов. Как и класс b.java, он не содержит логики (методов) и служит исключительно для хранения публичных полей. Судя по наличию двух полей типа b, этот класс может использоваться для управления заголовком и хвостом списка или для хранения двух различных цепочек данных.
- Архитектурная роль:
Data Model / State Holder (Модель данных / Хранитель состояния). В архитектуре приложения этот класс выполняет роль легкого контейнера. Он может использоваться для передачи состояния между игровыми модулями или для организации более сложных структур данных на базе узлов класса b.
- Внешние зависимости:
Класс имеет одну внутреннюю зависимость:b.java: Используется для определения типов полей b и d.

---

### Список функций (Методы):

- Методы отсутствуют. Класс представляет собой "структуру" в стиле языка C, перенесенную в Java для минимизации накладных расходов на вызовы методов.

---

### Поля данных (Переменные):

Поскольку класс предназначен для прямого доступа к данным, ниже приведено описание его полей:

| Имя поля | Тип | Начальное значение | Описание |
| --- | --- | --- | --- |
| c | short | 0 | Числовой идентификатор или счетчик. |
| a | byte | 1 | Тип состояния или флаг категории. |
| e | boolean | false | Логический флаг (например, статус активности или завершения). |
| b | b | null | Ссылка на первый объект (узел) типа b. |
| d | b | null | Ссылка на второй объект (узел) типа b. |

---

### Константы:

В файле присутствуют жестко заданные значения при инициализации полей: `0` для short, `1` для byte и `false` для boolean.


---

### Документация ресурсов директории /res

| Файл / Путь | Описание содержимого | Основной потребитель (Класс) | Архитектурная роль |
| --- | --- | --- | --- |
| res/i | Иконка приложения, отображаемая в меню телефона. | MANIFEST.MF | Ресурс развертывания. |
| res/s | Пакет звуковых данных (эффектов). | CrystalMidlet.java | Аудио-активы. |
| res/im | Графические ресурсы интерфейса: логотипы, элементы меню, фоны окон. | i.java (через c.java) | UI-активы. |
| res/ic | Игровые спрайты, иконки бонусов и элементы HUD. | h.java | Игровые спрайты. |
| res/lf | Бинарные конфигурации уровней (координаты объектов, типы тайлов). | h.java (через c.java) | Данные уровней. |
| res/tf | Данные тайлов переднего плана (Tile Front). | h.java (через c.java) | Геометрия мира. |
| res/bg | Данные тайлов фонового слоя (Background). | h.java (через c.java) | Декорации мира. |
| res/b | Маски коллизий и наборы спрайтов игрового персонажа. | a.java (через c.java) | Физика и анимация игрока. |
| res/r | Записанный поток игровых событий для режима воспроизведения. | d.java | Данные реплея. |
| res/if0, if1, if2 | Изображения слоев переднего плана для различных тем оформления. | h.java | Тематическая графика. |
| res/ib0 | Изображение фонового слоя для первой темы оформления. | h.java | Тематическая графика. |

---


Файл `/mnt/data/s` — это не один звук, а контейнер с **11** рингтонами (что совпадает с `Sound[11]` в скрипте).

Структура файла:

- uint16 BE count = 0x000B (11)
- далее 11 значений uint16 BE — длины каждого рингтона в байтах: 28, 30, 29, 31, 30, 28, 31, 46, 66, 15, 15
- затем подряд идут 11 бинарных блоков данных этих длин

Каждый блок начинается с сигнатуры `02 4A 3A ...` (ASCII `\x02J:`), что соответствует **Nokia Smart Messaging ringtone user data** (то, что часто встречается как OTT/OTA ringtone payload; в SCKL-строках это выглядит как `//SCKL... 024A3A...`).

Итого по формату:

- Внутри res/s лежат бинарные Nokia Smart Messaging рингтоны (по сути “OTT-пэйлоад”), а не MIDI/AMR/WAV и не MIDP FORMAT_TONE-тон-секвенция.




### Подробный анализ специфических файлов

- res/lf (Level Files): Содержит структуру уровней. Метод h.b(int) считывает из этого файла количество объектов, их начальные координаты, типы (враги, платформы) и параметры движения.
- res/b (Body/Ball): Включает в себя 25 кадров анимации персонажа и соответствующие им булевы маски для попиксельной проверки столкновений в методе a.a(int, int, boolean).
- res/r (Replay): Хранит последовательности тиков и соответствующих им кодов клавиш. Используется классом d для имитации ввода пользователя в демонстрационном режиме.
- res/ifX и res/ib0: Эти файлы обеспечивают визуальное разнообразие уровней. Движок выбирает конкретный индекс файла (0, 1 или 2) в зависимости от текущей темы, заданной в данных уровня.
- kjmGlobal_images_themeX: Хотя эти файлы присутствуют в списке, в коде они явно не вызываются по именам. Вероятно, они являются частями пакетов, которые распаковываются или выбираются динамически при сборке под конкретные устройства.


Для успешного переноса игры **Bounce Back** на **PSPSDK (C/C++)**, основываясь на анализе исходного кода Java MIDP 2.0, необходимо учитывать следующие ключевые зависимости и логические блоки:

---

### Архитектурная карта переноса

| Модуль Java (Исходник) | Функционал для реализации в C (PSPSDK) | Особенности реализации |
| --- | --- | --- |
| c.java | Resource Loader | Необходимо реализовать чтение заголовков и смещений из файлов пакетов (res/lf, res/b и др.). Метод b(int) заменяется на fseek. |
| g.java | Tile Engine & Collisions | Перенос системы тайловых слоев и масок столкновений. Массив трансформаций p нужно сопоставить с флагами рендеринга PSP GU. |
| a.java | Player Physics | Ядро физики персонажа: гравитация, инерция и выталкивание из тайлов при смене спрайта. |
| h.java | Game Loop & Level Manager | Главный цикл игры, координация между игроком и миром, загрузка уровней из бинарных данных res/lf. |
| i.java | UI & Menu System | Система отрисовки меню и текстовых блоков с переносом строк. |
| CrystalMidlet.java | Application Lifecycle & Save Data | Замена RecordStore (RMS) на стандартную работу с файлами на Memory Stick. |

---

### Ключевые технические узлы для порта

- Система ресурсов (пакеты):
Все ресурсы упакованы в бинарные файлы с кастомным заголовком (2 байта — количество записей, затем массив длин). В C++ потребуется структура, аналогичная классу c, для индексированного доступа к записям.
- Графический подслой:
Игра использует Nokia DirectGraphics для поворотов и отражений спрайтов. На PSP это реализуется через вертексные массивы или встроенные функции аппаратного ускорения поворота текстур.
- Физика и столкновения:
Метод a.a(int, int, boolean) выполняет проверку попиксельно, используя булевы маски из файла res/b. Для порта важно сохранить формат этих масок, так как они определяют точность взаимодействия с объектами.
- Сохранение состояния (RMS):
Класс CrystalMidlet сохраняет три записи: настройки, рекорды и состояние прерванной игры. В PSPSDK это потребует реализации парсинга и записи структур через fopen/fwrite вместо методов RecordStore.
- Управление:
Коды клавиш мобильного телефона (2, 4, 5, 6) в методе h.keyPressed должны быть переназначены на PSP_CTRL_CROSS, PSP_CTRL_SQUARE и кнопки D-pad.

---

### Файлы ресурсов, критичные для порта:

1. res/lf: Полная топология уровней и позиции врагов.
2. res/b: Физические параметры «тела» игрока и анимации.
3. res/tf / res/bg: Наборы тайлов для формирования окружения.
4. res/r: Данные для системы реплея (если планируется перенос режима Demo).

---

### Документация парсера уровней (generate_maps_from_lf.py)

- Общее описание:
Скрипт выполняет десериализацию бинарных данных уровней (res/lf) и сопутствующих метаданных тайлов (res/tf). Он автоматизирует процесс сборки графических спрайтов из файлов-контейнеров (if0, if1, ic) в единую карту уровня, учитывая флаги состояния тайлов и параметры игрока.
- Алгоритм работы с ресурсами:
Парсер реализует логику класса c.java, считывая 2-байтовый заголовок (>H), который определяет количество чанков и их размеры. Это критически важная часть для порта: на PSP вам потребуется аналогичная функция для доступа к смещениям внутри файлов ресурсов.

---

### Ключевые блоки данных и их логика

#### 1. Метаданные уровня (parse_level_metadata)

Парсер извлекает параметры из первого чанка каждого уровня в `res/lf`:

- Spawn Point: Рассчитывается с учетом типа игрока.Если player_type == 0 (маленький шар), смещение составляет 8 пикселей.Если player_type != 0 (большой шар), смещение — 12 пикселей.
- Размер шара: Используется для корректной отрисовки хитбокса игрока (16 или 20 пикселей).

#### 2. Метаданные тайлов (parse_tf_metadata)

Скрипт воссоздает структуру заголовка из `g.java` (строки 147–166):

- split_point: Определяет, когда нужно переключиться на чтение второго чанка в файле tf.
- bg_color: Извлекается как 4-байтовое целое число (ARGB), определяющее цвет «воды» или темных зон.
- Атрибуты тайла: Для каждого ID фиксируются индекс изображения, тип коллизии и флаги ротации.

#### 3. Обработка флага 0x80 (apply_tile_rotation)

- Флаг 0x80 в байте тайла не является трансформацией (вращением).
- Согласно логике g.java:601-604, этот флаг служит сигналом для заливки фона тайла цветом bg_color перед отрисовкой самого спрайта. Это необходимо для корректного отображения прозрачных тайлов над водой.

---

### Технические соответствия для PSPSDK

| Функция Python | Аналог в C / PSPSDK | Примечание для порта |
| --- | --- | --- |
| struct.unpack('>H', ...) | ntohs() или ручной сдвиг байтов | Java использует Big-Endian, PSP — Little-Endian. Необходимо инвертировать порядок байтов при чтении. |
| Image.paste() | sceGuCopyImage или blit | Рендеринг карты уровня на PSP лучше делать через текстурные атласы. |
| tile_byte & 0x7F | id = byte & 0x7F | Получение чистого ID тайла без учета спецфлагов. |
| io.BytesIO(chunk) | fmemopen или прямой доступ | Работа с графикой напрямую из буфера в памяти Memory Stick. |

---

### Особенности маппинга тайлов

Ваш скрипт подтверждает распределение спрайтов:

- 0–103: Загружаются из if0.
- 104–110: Загружаются из if1 (соответствуют тайлам 110–116).
- Специальные объекты: Загружаются из ic.

---

Стратегия создания движка с «нулевой конвертацией» (Zero-Conversion) требует точного воссоздания логики класса `c.java` и понимания структуры каждого бинарного файла. Это позволит PSP-версии игры считывать ресурсы напрямую из распакованной папки JAR-архива.

Ниже приведена спецификация для реализации остальных парсеров на C/C++ для PSPSDK.

---

### 1. Базовый парсер контейнеров (Аналог c.java)

Все файлы в `res/` (кроме манифеста) используют формат чанков. Для PSP необходимо реализовать структуру, которая будет считывать заголовок один раз и хранить массив смещений в памяти.

- Формат заголовка:uint16_t count (Big-Endian) — количество записей. uint16_t sizes[count] (Big-Endian) — размер каждой записи.
- Смещение данных: Начинается сразу после массива размеров: 2 + (count * 2).

---

### 2. Парсер графики и текстур (res/if0, res/if1, res/im, res/ic)

Эти файлы представляют собой просто наборы PNG-изображений, упакованных в чанки.

- Логика загрузки: Пройтись по всем чанкам контейнера и передать каждый буфер в функцию загрузки текстур PSP (например, через библиотеку libpng или stb_image).
- Прозрачность: В Java-коде используется DirectUtils.createImage, который корректно обрабатывает прозрачность PNG. На PSP важно проверять формат цвета (обычно GU_PSM_8888).
- Трансформации: Поля ротации из tf должны применяться на лету при отрисовке полигонов (вертексов) на PSP.

---

### 3. Парсер физических масок (res/b)

Этот файл критически важен для физики прыжков и столкновений шара.

- Структура данных:Первый чанк содержит маски коллизий. byte count — количество масок. Для каждой маски: byte width, byte height, а затем width * height булевых значений (в Java readBoolean занимает 1 байт).
- Применение: Эти маски должны быть загружены в std::vector<bool> или битовые поля для проверки пересечения шара с тайлами.

---

### 4. Парсер звуковых эффектов (res/s)

Класс `CrystalMidlet` загружает звуки из этого файла.

- Тип данных: Внутри чанков res/s находятся данные, которые Java-класс com.nokia.mid.sound.Sound интерпретирует как аудио.

---

### 5. Спецификация файлов уровней (res/lf)

| Чанк | Содержимое | Особенности |
| --- | --- | --- |
| Чанк 1 | Метаданные уровня. | Содержит тип игрока, спаун и количество динамических объектов (j). |
| Чанк 2 | Карта тайлов. | Начинается с height (1 байт) и width (1 байт). |

---

### Технические рекомендации для порта на PSP

1. Endianness (Порядок байтов): Все числовые данные в ресурсах (short, int) записаны в Big-Endian. На PSP (Little-Endian) обязательно используйте функции преобразования, такие как __builtin_bswap16 и __builtin_bswap32.
2. Память: Поскольку оригинальная игра работала на устройствах с 1-2 МБ RAM, вы можете позволить себе загрузить все метаданные тайлов (tf) и уровней (lf) в память PSP один раз при запуске.
3. Файловая система: Рекомендуется создать виртуальную файловую систему (VFS), которая будет прозрачно читать данные из одного большого файла ресурсов, имитируя логику getResourceAsStream.


---

Ниже представлен структурированный отчет по распределению тайлов на основе анализа 22 игровых уровней (`res/lf`). Данные извлечены с помощью скрипта `count_tiles.py` и дополнены контекстом из исходного кода `h.java`, `g.java` и `a.java`.

### Статистика распределения тайлов (Levels: 22) - сгенерирована `count_tiles_on_levels.py`

| ID Тайла | Кол-во | Процент | Описание и архитектурная роль (согласно коду) |
| --- | --- | --- | --- |
| 0 | 44255 | 71.55% | Пустое пространство / Фон. При установленном флаге 0x80 заполняется цветом bg_color (вода/глубина). |
| 110 | 5660 | 9.15% | Основная платформа (Theme 1). Загружается из /res/if1. Основной физический блок уровня. |
| 111 | 4313 | 6.97% | Платформа (Theme 1). Загружается из /res/if1. |
| 112 | 3280 | 5.30% | Платформа (Theme 1). Загружается из /res/if1. |
| 113-116 | 2611 | 4.22% | Вспомогательные блоки. Завершающие элементы геометрии из /res/if1. |
| 2 | 191 | 0.31% | Твердый блок. Стандартный элемент коллизии из /res/if0. |
| 85, 86 | 252 | 0.41% | Декоративные / Твердые элементы. Вспомогательная графика из /res/if0. |
| 93, 94, 97, 98 | 303 | 0.46% | Элементы Колец. Интерактивные объекты, требующие сбора/прохождения. Обрабатываются в a.java и h.java. |
| 34 | 80 | 0.13% | Чекпоинт. Сохраняет позицию игрока (spawn point) при касании. |
| 30 | 63 | 0.10% | Кристалл (Points). Дает 2500 очков при сборе. |
| 101, 102 | 96 | 0.16% | Финишные кольца. Триггеры завершения уровня или перехода состояния. |
| 87, 88 | 74 | 0.12% | Шипы (Spikes). Смертельные препятствия. Вызывают метод k() (смерть игрока). |
| 12 | 23 | 0.04% | Дополнительная жизнь. Увеличивает счетчик жизней o.h на 1. |
| 11, 15, 18, 22 | 64 | 0.10% | Модификаторы / Пампы. Прыжковые панели и зоны изменения физики. |
| Остальные | < 0.2% | - | Редкие декорации, специфические триггеры и анимированные объекты. |

---

### Технические выводы для документации:

- Доминирование пустых зон: Более 70% карты не содержат физических объектов, что позволяет оптимизировать проверку коллизий в C++ через ранний выход из цикла.
- Ресурсная зависимость: Основной визуальный вес уровней приходится на файлы /res/if1 (тайлы 110-112) и /res/if0 (базовая геометрия).
- Логическая плотность: Интерактивные объекты (чекпоинты, кольца, бонусы) составляют менее 2% от общего объема данных, но требуют основной части кода обработки в классе a.java.



Вывод скрипта `parse_tf.py` предоставляет ключевую информацию о внутреннем устройстве тайловой системы игры. Эти данные являются "картой соответствия", которая связывает логические ID тайлов из файлов уровней с визуальными активами и физическими свойствами.

---

### Документация параметров Tile Format (tf)

#### 1. Конфигурация ресурсов

- Количество чанков (Chunks): 2. Подтверждает структуру загрузки в h.java, где файл tf читается двумя последовательными вызовами c2.a().
- Распределение изображений:if0 (104 изображения): Основной набор спрайтов (индексы 0–103).if1 (7 изображений): Дополнительные тайлы платформы (индексы 104–110).
- Базовый размер тайла: 12x12. Это важное уточнение: несмотря на то, что в игре тайлы часто масштабируются до 16x16, исходные данные в ресурсах имеют размер 12 пикселей.
- Split point: 110. Это критический индекс. Когда движок доходит до тайла с ID 110, он переключает чтение метаданных с первого чанка на второй.
- Background color (0x7f00007f): Темно-синий/фиолетовый цвет. Он используется для заполнения фона за тайлами, у которых установлен флаг прозрачности 0x80.

#### 2. Система анимаций (U: 20)

Движок поддерживает 20 независимых анимаций для тайлов.

- Длительность (duration 5): Все анимации имеют одинаковую скорость обновления кадров.
- Кадры: Анимации состоят из 2 или 3 кадров. В PSP-версии вам потребуется реализовать глобальный счетчик тиков, чтобы анимировать эти тайлы синхронно с оригиналом.

---

### Анализ метаданных тайлов

Таблица описывает свойства каждого объекта в мире игры:

| Поле | Описание (из g.java) | Значения |
| --- | --- | --- |
| Type | Логический тип тайла (v[b4]). | 0: Фон, 1: Интерактивный/Твердый объект. |
| Image | Индекс спрайта (T[b4]). | Ссылка на конкретную картинку из объединенного списка if0 + if1. |
| Flags | Параметры трансформации (b[b4]). | Определяют поворот (0x01, 0x02, 0x03) через Nokia DirectGraphics. |
| Coll | Тип коллизии (l[b4]). | 0: Нет, 1: Сложная маска, 2: Твердый блок, 3: Наследование. |

#### Ключевые наблюдения по ID тайлов:

- ID 0 (Воздух): Тип 0, Коллизия 0. Пустое пространство, не отрисовывается и не блокирует игрока.
- ID 110–112 (Основные платформы): Используют изображения 104–106 из if1 и имеют тип коллизии 2 (полностью твердые блоки).
- ID 3, 113: Имеют тип коллизии 1. Это означает, что для них в файле tf следом идут 256 байт (16x16) булевой маски для попиксельной проверки столкновений.
- ID 4, 5, 6 и 114, 115, 116: Имеют тип коллизии 3. Это "наследуемая" коллизия — они копируют физическую маску у другого тайла, указанного в поле color_ref.

---

### Рекомендации для реализации на PSPSDK

1. Загрузка текстур: Создайте массив из 111 указателей на текстуры. Загрузите первые 104 из if0, затем оставшиеся 7 из if1.
2. Структура TileDef:C++struct TileDef {
    uint8_t type;
    uint8_t imageIdx;
    uint8_t rotationFlags;
    uint8_t collisionType;
    bool* pixelMask; // Заполняется, если collisionType == 1
};
3. Обработка Split Point: В вашем загрузчике на C++ обязательно добавьте условие: if (tileId >= splitPoint) { switch_to_chunk(2); }, иначе данные для тайлов 110+ будут считаны некорректно.
4. Endianness: Не забывайте преобразовывать bg_color (Int32) из Big-Endian в Little-Endian при чтении на PSP.



### Итог готовности компонентов:

- Уровни (lf): Парсер готов (Python), структура понятна.
- Тайлы (tf): Метаданные расшифрованы, маппинг составлен.
- Графика (if0/if1): Схема прямой загрузки PNG-чанков ясна.
- Управление: Коды клавиш из i.java и h.java известны (2, 4, 5, 6).